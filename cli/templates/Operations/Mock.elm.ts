export default (): string => "module GraphQL.Operations.Mock exposing (Error(..), generate)\n\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Schema as Schema\nimport Json.Encode\n\n\ntype Error\n    = Error\n\n\ngenerate :\n    Can.Document\n    ->\n        Result\n            (List Error)\n            (List { name : String, body : Json.Encode.Value })\ngenerate doc =\n    Ok (List.map definition doc.definitions)\n\n\ndefinition : Can.Definition -> { name : String, body : Json.Encode.Value }\ndefinition (Can.Operation def) =\n    { name =\n        Maybe.map Can.nameToString def.name\n            |> Maybe.withDefault \"query\"\n    , body =\n        Json.Encode.object\n            [ ( \"data\", mockDefinition def )\n            ]\n    }\n\n\nmockDefinition : Can.OperationDetails -> Json.Encode.Value\nmockDefinition def =\n    Json.Encode.object\n        (List.concatMap (encodeField Nothing) def.fields)\n\n\nencodeField : Maybe String -> Can.Selection -> List ( String, Json.Encode.Value )\nencodeField typename field =\n    case field of\n        Can.FieldObject details ->\n            -- Note, still need to handle `details.wrapper`\n            [ ( Can.getAliasedName field\n              , Json.Encode.object\n                    (List.concatMap (encodeField (Just details.object.name)) details.selection)\n                    |> wrapEncoder details.wrapper\n              )\n            ]\n\n        Can.FieldUnion details ->\n            case onlyOneUnionCaseAndScalars (List.reverse details.selection) ( Nothing, [] ) of\n                ( Just selectedVariant, otherFields ) ->\n                    [ ( Can.getAliasedName field\n                      , Json.Encode.object\n                            (Can.UnionCase selectedVariant\n                                :: otherFields\n                                |> List.concatMap (encodeField (Just (Can.nameToString selectedVariant.tag)))\n                            )\n                            |> wrapEncoder details.wrapper\n                      )\n                    ]\n\n                ( Nothing, _ ) ->\n                    []\n\n        Can.FieldScalar details ->\n            case details.type_ of\n                Schema.Scalar \"typename\" ->\n                    case typename of\n                        Nothing ->\n                            [ ( Can.getAliasedName field\n                              , Json.Encode.string \"WRONG\"\n                              )\n                            ]\n\n                        Just nameStr ->\n                            [ ( Can.getAliasedName field\n                              , Json.Encode.string nameStr\n                              )\n                            ]\n\n                _ ->\n                    [ ( Can.getAliasedName field\n                      , Schema.mockScalar details.type_\n                      )\n                    ]\n\n        Can.FieldEnum details ->\n            case details.values of\n                [] ->\n                    [ ( Can.getAliasedName field\n                      , Json.Encode.null\n                      )\n                    ]\n\n                top :: _ ->\n                    [ ( Can.getAliasedName field\n                      , Json.Encode.string top.name\n                            |> wrapEncoder details.wrapper\n                      )\n                    ]\n\n        Can.UnionCase details ->\n            List.concatMap (encodeField typename) details.selection\n\n\nwrapEncoder : Schema.Wrapped -> Json.Encode.Value -> Json.Encode.Value\nwrapEncoder wrapped val =\n    case wrapped of\n        Schema.UnwrappedValue ->\n            val\n\n        Schema.InList inner ->\n            Json.Encode.list identity [ wrapEncoder inner val ]\n\n        Schema.InMaybe inner ->\n            wrapEncoder inner val\n\n\nonlyOneUnionCaseAndScalars : List Can.Selection -> ( Maybe Can.UnionCaseDetails, List Can.Selection ) -> ( Maybe Can.UnionCaseDetails, List Can.Selection )\nonlyOneUnionCaseAndScalars sels (( maybeFoundUnion, otherFields ) as found) =\n    case sels of\n        [] ->\n            found\n\n        (Can.UnionCase union) :: remain ->\n            if maybeFoundUnion /= Nothing then\n                onlyOneUnionCaseAndScalars\n                    remain\n                    found\n\n            else\n                onlyOneUnionCaseAndScalars\n                    remain\n                    ( Just union, otherFields )\n\n        (Can.FieldScalar scalar) :: remain ->\n            onlyOneUnionCaseAndScalars\n                remain\n                ( maybeFoundUnion, Can.FieldScalar scalar :: otherFields )\n\n        _ :: remain ->\n            onlyOneUnionCaseAndScalars\n                remain\n                found\n"